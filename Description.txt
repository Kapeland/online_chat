1) Этот код создавался на ОС Windows и не факт, что будет работать на других ОС.
Этот код писался в Clion (если это на что-нибудь может повлиять).
В данный момент работает только на локальном сервере.
Важно! Для использования нужно включить сначала сервер, а затем только включать клиентов.
Для запуска необходимо собрать проект самостоятельно.
Также перед запуском стоит создать в папке, где будет лежать приложение-сервер, два текстовых файла:
dataBase.txt и dataBaseFriends.txt Это нужно для того, чтобы функции работы с файлами работали корректно.

2)Инструкция для пользователя.
Вас встречает небольшое текстовое сообщение, в котором в кавычках выделены ключевые команды.
Команды нужно вводить так, как они написаны внутри кавычек.
Первым делом нужно либо войти, либо зарегистрироваться. Для этого есть соответствующие команды.
Команды вводятся в одну строку.
После выбора команды, будут выведены сопутствующие сообщения, которые подскажут что делать дальше.
В данный момент, если что-то пошло не так, как хотелось, или Вы хотите закончить общение, то придётся закрыть окно программы.

3)Описание решения.
	Клиент.
	Первым делом нужно создать сокет клиента, и указать адрес сервера.
	Можно было бы предоставить пользователю выбор касаемо адреса сервера, но для удобства запуска и отладки было принято решение сделать его локальным.
	Далее идёт попытка присоединения к серверу, и если она заканчивается успехом то пользователю предлагаются возможные варианты действий.
	Однако тут же возникает проблема, что необходимо сначала закончить вход первого пользователя в чат,
	и только потом пытаться выполнять какие-то команды на последующих. (В общих чертах, пользователи должны входить в систему
	согласно тому, как открывались приложения.) (Подробнее о том, почему такое возникает в описании сервера.)

	Создание нового пользователя: это действие сопровождается дополнительными отправками служебных сообщений серверу.
	Это нужно для того, чтобы сервер понимал какие команды вводит пользователь и действовать согласно этим командам.
	Была обработана ситуация, возникающая при попытке создания пользователя с неуникальным логином.
	Для этого был использован цикл while(true), условием выхода из которого является получение служебного сообщения от сервера.

	Вход в систему без регистрации: на стороне сервера была обработана такая ситуация, что пользователь вводит "плохие" данные.
	Например, неверный логин или пароль. Всё это требует повторного обрабатывания, которые было реализовано в цикле while(true), где
	условием выхода является получение служебного сообщения от сервера.
	Также было добавлено ограничение на количество попыток ввода данных.
	Это нужно было для того, чтобы в некотором роде обеспечить защиту данных от перебора и облегчить нагрузку на сервер.

	После того как пользователь тем или иным способом зайдёт в систему, запускаются два потока.
	Один на чтение данных с сервера, другой на отправку.

	Чтение: было реализовано в цикле while(true), чтобы обеспечить постоянное чтение данных с сервера.
	Единственным способом выйти из этого цикла является отключение сервера.
	Проверка этого факта была реализована на ограничении попыток принять что-то от сервера.
	В случае, если попытки исчерпываются, то выводится сообщение о том, что сервер выключен и программа выходит из цикла
	и в скором времени завершает работу, предварительно закрыв сокет (чтобы потом другие могли его занять).
	К сожалению, данная реализация не позволяет отличить действительно ли происходит какая-то проблема при получении сообщений от сервера
	или же он просто отключился.

	Отправка: всё так же реализована внутри цикла while(true), условием выхода из которого
	является исчерпание попыток отправить сообщение. Эта ситуация сопровождается выводом соответствующего сообщения.
	В реальности же, если сервер действительно отключён, то выход из предыдущей функции произойдёт гораздо быстрее и именно она
	в скором времени завершит работу программы.
	Отличает эту функцию от предыдущей то, что она не просто отправляет серверу всё, что пишет пользователь и отображает отправляемые сообщения,
	а то, что она отслеживает написание специальных команд, которые отвечают за добавление в друзья или же получения списка друзей.


	Сервер.
	Первым делом нужно указать адрес сервера. Решения, принятые касаемо этого описаны в графе клиента.
	Далее создаётся серверный сокет. Затем к этому сокету привязывается адрес, чтобы сокет стал доступен клиентам.

	Далее происходит чтение из файлов (в них сохраняются базы данных. А именно, список друзей и список пользователей
	когда-либо входивших в систему). Чтение реализовано простыми функциями чтения из файла.
	Единственное, что отличает файл со списком друзей от другого файла, является наличие специальных строк (****).
	Это нужно было для того, чтобы разделить к кому какой список относится.
	Вся информация в файлы заносилась и считывалась построчно.
	Функция записи в файл аналогичны функциями чтения.

	Сами базы было решено хранить в виде MAPа. Это решение оправдывает себя в основном потому, что удобно что-то
	привязать к какому-то пользователю (будь то пароль или список друзей).

	Дальше по ходу программы идёт listening. Отвечая на вопрос, почему чтение было сделано раньше листенинга,
	можно сказать следующее: хотелось, чтобы при виде сообщения о том, что сервер слушает (т.е. готов принимать сокеты),
	было понятно, что всё хорошо и готово к работе над обработкой пользователей.

	Далее идёт цикл for от 0 до максимального количества пользователей, которое устанавливается константой в "шапке" кода.
	По идее нужно было бы сделать это не в цикле for, а в цикле while(true), чтобы бесконечно обрабатывать пользователей,
	но для этого есть несколько проблем. Во-первых, не получалось обработать условие таким образом, чтобы было ограничено
	количество пользователей в один момент времени. Во-вторых, программа использует массив сокетов для запоминания подключившихся
	пользователей. Оказалось гораздо удобнее перемещаться по этому массиву при помощи индекса в цикле for, нежели чем
	при хождении по циклу while. В добавок к этому нужно было бы проверять момент выхода за границы массива.
	Для понимания ситуации, можно представить следующий пример. Стоит ограничение на 10 пользователей одновременно.
	Для этого нужно ещё хранить переменную отвечающую за этот фактор, что тоже добавляет проблем (об этом чуть позже).
	Мы в массив сокетов заносим информацию примерно в таком виде arr[cntOfUsers] = ... Мы вот так добавили 5 людей. Однако в какой-то
	момент из системы вышел 2‑й пользователь. В таком случае логично было бы отнять количество одновременно подключенных пользователей.
	После такого действия становится понятным, что при добавлении 6‑го пользователя, наш массив уже не будет нам полезен.
	Возможно для решения такой проблемы можно было бы сделать специальную переменную, для индексации по этому массиву, но таким
	образом конструкция не будет отличаться от цикла for. Таким образом, что в случае for, что в случае while приходится ограничивать максимальное
	количество пользователей, чтобы не делать слишком большой массив. Как-то сортировать его, изменять размер не имеет смысла, поскольку
	в этом цикле for запускается на каждой итерации новый поток для нового пользователя с порядковым номером. Этот номер используется в обрабатывающих функциях
	для доступа к массиву сокетов. Возможно эту проблему решило бы передавание в поток помимо номера ещё и сокет, но как это сделать вопрос, к сожалению,
	остался	открытым.

	В этом цикле идёт обработка служебных сообщений от пользователя, когда он хочет подключиться.
	В случае регистрации всё просто. Считываются принятые данные, они проверяются и если всё корректно, то пользователь
	добавляется в систему. В противном случае процесс повторяется до тех пор, пока пользователь не введёт правильные данные.
	Также, после успешной регистрации, в файле сохраняется база данных. В добавок к этому,
	выводится сообщение для всех пользователей о подключении нового. Для этого используется специальная
	функция, которая отправляет это сообщение всем, кроме нового пользователя. Она как раз и использует переменную цикла, чтобы
	понять по какому токену что отправлять. Также было добавлено специальное сообщение, говорящее о том что зашёл именно друг.
	Для понимания представим ситуацию: пользователь А добавил пользователя В, в таком случае при подключении пользователя В,
	пользователю А будет об этом сообщено. Информация о друзьях берётся из базы Друзей.
	В случае простой авторизации всё несколько сложнее. Всё дело в том, что обмен токенами возможен только в том случае,
	если сервер примет запрос на подключение.(**) Но в этом и проблема, поскольку не факт, что этого пользователя нам нужно подключать.
	Специально для этого были сделаны проверки на правильность введённых данных (обмен служебными сообщениями между сервером и клиентом)
	и введено ограничение на количество попыток. В случае успеха также выводится сообщение о подключении нового пользователя.

	(**)С этим связана проблема, о которой говорилось в самом начале. Если открыть сначала 1‑е приложение-клиент, затем второе,
	начать вводить там данные, то отправить их не получится, поскольку сервер не готов принимать данные от этого пользователя.
	Это будет возможно только на следующей итерации цикла. По этой причине возникает неправильное поведение программы у дальнейших пользователей,
	если не завершить вход у предыдущих.

	Выход из этого глобального цикла происходит при достижении лимита пользователей.
	В таком случае всем подключенным пользователям отправляется сообщение о перегрузке сервера и предложением зайти потом
	После этого закрываются все подключенные сокеты, сокет сервера, очищаются базы данных и завершается работа программы.
	При текущей реализации это единственный возможный способ нормально завершить программу.

	Немного вернёмся к тому, что происходит после того, как пользователь вошёл в систему.
	На каждой такой итерации цикла запускается новый поток, который обрабатывает приём сообщений.
	За это отвечает очень похожая функция, что была у клиента, просто у неё другие проверяемые параметры и,
	соответственно, другое действие согласно этим параметрам. Например, получено сообщение, что нужно выслать список друзей,
	она и отправляет список друзей. Нужно добавить друга, она добавляет его в базу данных и сохраняет её в файл.
	Также эта функция отправляет полученное сообщение всем другим пользователям. Делает это она аналогичным образом
	функции, которая обрабатывает оповещение о подключённом пользователе.